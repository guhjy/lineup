---
title: R/lineup user guide
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{R/lineup user guide}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8](inputenc)
---

```{r knitr_options, include=FALSE}
library(knitr)
opts_chunk$set(fig.width=7, fig.height=4.5,
               dev.args=list(pointsize=16))
```

[R/lineup](https://github.com/kbroman/lineup) is an
[R](http://www.r-project.org) package with tools for
detecting and correcting sample mix-ups between two sets of
measurements, such as between gene expression data on two tissues, and
between gene expression data and marker genotype data. The
package is particularly aimed at eQTL data for an experimental cross
and as a companion to [R/qtl](http://rqtl.org).

This document provides a brief tutorial on the use of the package.
(**Though, as you'll see, I'm not done with this.**)

We first load the R/qtl and R/lineup packages.

```{r load_libraries}
library(qtl)
library(lineup)
```

```{r load_data_hidden, include=FALSE}
data(f2cross)
data(expr1)
data(expr2)
data(pmap)
data(genepos)
```


We will consider a set of simulated data as an example. This is an
F~2~ intercross with `r nind(f2cross)` individuals genotyped at `r
totmar(f2cross)` autosomal markers, and with gene expression data on
`r ncol(expr1)` genes in two tissues.

Let's load the data.

```{r load_data_shown, eval=FALSE}
data(f2cross)
data(expr1)
data(expr2)
data(pmap)
data(genepos)
```

The dataset `f2cross` is the experimental cross, in the form used by
[R/qtl](http://rqtl.org) (that is, an object of class `"cross"`).  The
datasets `expr1` and `expr2` are matrices with the gene expression
data, with individuals as rows and genes as columns. The object `pmap` is a
physical map of the markers in `f2cross` (with positions in Mbp), and
`genepos` is a data frame with the genomic positions (in Mbp) of the
genes in `expr1` and `expr2`.

The expression datasets were stored as integers; let's divide all
values by 1000, to simplify some later plots.

```{r scale_expr}
expr1 <- expr1/1000
expr2 <- expr2/1000
```


## Lining up expression data

We'll first look at the gene expression data in `expr1` and `expr2`
and look for possible sample mix-ups. The basic scheme (see
[Broman et al. 2014](http://arxiv.org/abs/1402.2633)) is to identify a
set of genes with highly correlated expression between the two
tissues, and then use these genes to measure the association between
each sample in the first tissue with each sample in the second tissue.

To start, note that there are
just 98 individuals in each data set, and they're not the same individuals.

```{r summary_expr}
nrow(expr1)
nrow(expr2)
all(rownames(expr1) == rownames(expr2))
```

The function `findCommonID()` helps to find individuals that are in
common between the two matrices. For matrices, the default is to use
the row names as identifiers.

```{r find_commond_ind_expr}
eid <- findCommonID(expr1, expr2)
length(eid$first)
```

In the returned object, `eid$first` and `eid$second` contain indices
for `expr1` and `expr2`, respectively, to get them to line up.

Now let's look for at the correlation between tissues for each gene,
to identify genes that are highly correlated between the two tissues.
We subset the rows with the IDs in `eid`, so that the rows
correspond.

The function `corbetw2mat()` can be used to calculate portions of the
correlations between columns of two different matrices . With
`what="paired"`, we assume that the two matrices have the same number
of columns (say $p$), and that column $i$ in the first matrix corresponds to
column $i$ in the second matrix, and we calculate just the $p$
correlation values, for the paired columns.

```{r find_correlated_genes}
cor_ee <- corbetw2mat(expr1[eid$first,], expr2[eid$second,], what="paired")
```

Here's a histogram of these `r length(cor_ee)` correlations.

```{r hist_corr_betw_tissues}
par(mar=c(5,4,1,1))
hist(cor_ee, breaks=seq(-1, 1, len=101),
     main="", las=1, xlab="Correlation in gene expression between tissues")
```

You can see that this is totally contrived data. Most genes have a
positive correlation between the two tissues, with a bunch in the
0&ndash;0.5 range, and then a bunch more approaching 1. But then
`r round(mean(cor_ee < 0)*100)`% of genes are negatively correlated,
again with the pattern that most are in the range -0.5&ndash;0 and
then with a bunch near -1.

Let's focus on genes that have between-tissue correlation > 0.8 in
absolute value (of which there are `r sum(abs(cor_ee)>0.8)`), and then
look at the correlation, across these genes,
between samples in tissue 1 and samples in tissue 2. This is done with
the `distee()` function ("dist" for distance and "ee" for expression
vs. expression).

```{r distee}
d_ee <- distee(expr1[,abs(cor_ee)>0.8], expr2[,abs(cor_ee)>0.8], d.method="cor")
```

The result is an object of class `"lineupdist"`. If you plot the
result, you'll get two histograms: one of the self-self correlations,
and another of the self-nonself correlations.

```{r plot_distee, fig.height=9}
par(mar=c(5,4,2,1))
plot(d_ee)
```

For most individuals, the self-self correlation is near 1, but there
is a group of `r sum(pulldiag(d_ee) < 0.5)` individuals where the
self-self correlation is < 0.5.  Similarly, most of the self-nonself
correlations are between -0.5 and 0.5, but there's a group of
`r sum(!is.na(omitdiag(d_ee)) & omitdiag(d_ee) > 0.5)` correlations where the
self-nonself correlation is near 1.

You can use the helper functions `pulldiag()` and `omitdiag()` to do
these sorts of counts: `pulldiag()` pulls out the "diagonal" of the
correlation matrix (the self-self cases), and `omitdiag()` sets those
diagonal values to `NA`.

So to count the number of self-self correlations that are < 0.5, we
do the following.

```{r count_small_selfself}
sum(pulldiag(d_ee) < 0.5)
```

To count the number of self-nonself correlations that are > 0.5, we do
the following.

```{r count_large_selfnonself}
d_ee_nodiag <- omitdiag(d_ee)
sum( !is.na(d_ee_nodiag) & d_ee_nodiag > 0.5)
```


Applying the `summary()` function to the output of `distee()` gives a
set of tables of samples that are potential mix-ups.

```{r summary_distee}
summary(d_ee)
```

The first table is for samples in the first dataset: each row is a
sample. The first column is the maximum correlation between that
sample and the different samples in the second dataset, the second
column is the next-highest correlation, and the third column is the
self-self correlation. For the rows where the `selfc` (for self-correlation) value
is low but `maxc` is high, a sample mix-up is indicated. The last
column is the sample in the second dataset that has the highest
correlation.

In the second table, the rows correspond to samples in the second
dataset.

The rows with `NA` in the `selfc` column are cases where a sample
appears in one dataset but not the other. In these cases, we expect
the maximum correlation to be small, and it is.

However, there appear to be three pairs of sample mix-ups: (80,85),
(86,91), and (9,88). The have low values for `selfc` and high values
for `maxc`, consistently between the two datasets.  But we don't know
whether the mix-ups are in the first or second dataset.

In addition, sample 43 in the first dataset appears to be much sample
53 in the second dataset, but sample 43 in the second data set doesn't
look like any of the samples in the first dataset. This is the sort of
thing you see when there is a sample duplicate...where sample 43 in
the first data set is perhaps a copy of sample 53 in the first dataset.

If we make a scatterplot those two samples, which have correlation
`r round(cor(expr1["43",], expr1["53",]),2)` across all genes, it's
pretty clear that they're duplicates.

```{r plot_expr_dup, fig.width=7}
par(mar=c(5,4,1,1))
plot(expr1["43",], expr1["53",],
     xlab="Sample 43, expr1", ylab="Sample 53, expr1",
     las=1, pch=21, bg="slateblue", cex=0.7)
```


Let's drop sample 43 from the first dataset.

```{r drop_expr1_sample43}
expr1 <- expr1[rownames(expr1) != "43",]
```



## Lining up expression and genotype data

Let's turn now to lining up the expression data with the genotype
data. We'll consider one expression data set at a time.

The procedure is a bit like that above, in lining up the two
expression datasets. We first find gene/genotype pairs that are
highly associated; we'll look at the association be the expression of
a gene and the genotype at its genomic position (that is, genes with a
strong local-eQTL). We select genes with very strong local-eQTL, and
use them to form classifiers, of genotype from expression
phenotype. We then compare the predicted genotypes at the eQTL to the
observed marker genotypes.



```{r, lineup_geno, eval=FALSE}
plot2dist    # compare distee with rmsd and with cor
calc.locallod
combinedist
disteg
find.gene.pseudomarker
fscale
plotEGclass
```

#
